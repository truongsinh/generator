# Methods on generator objects

These are all the methods exposed by generators objects, in alphabetical order. Except for
`forEach`, all methods are inherited from the `Generator` prototype; only `forEach` is unique to
each generator; all other methods can be (and are) implemented using `forEach`.

## String selectors

Several methods that usually take a function as an argument also take a string instead, which is
equivalent to a function returning the so-named property of a given object.

This works with the following methods: `all`, `any`, `filter`, `groupBy`, `map`, `skipWhile`,
`sortBy`, and `takeWhile`. Passing a `thisObj` (where applicable) is obviosly useless when using a
string selector.

### Example

```javascript
var arr = [{foo: 5, bar: "!"}, {foo: -17, bar: "Hello"}, {foo: 0, bar: "world"}, {foo: -Math.PI, bar: " "}];
console.log(Generator(arr).sortBy("foo").map("bar").toArray().join("")); // Hello world!
```

# List of methods

## generator.all([func])

Returns `true` if all values generated by the source evaluate to true; otherwise returns `false`.
This is a short-circuit operation; as soon as a falsy value is found, evaluation of the source
generator stops.

If the optional function is given, the test is made on the results of calling the function on the
generated values; not on the values themselves. In other words, `gen.all(func)` is equivalent to
`gen.map(func).all()`. Instead of a function, you can also pass a string; see [String selectors](#string-selectors).

The method always returns a boolean, regardless of the actual generated values.

### Example

```javascript
console.log(Generator([13, true, "hello", {}]).all());	// true
console.log(Generator([13, true, null, {}]).all());		// false
```

## generator.and(other)
Returns a new generator that is a concatenation of the source generator and `other`.

### Example
```javascript
var first = Generator([1, 2, 3]);
var second = Generator([4, 5, 6]);

console.log(first.and(second).toArray()); // [1, 2, 3, 4, 5, 6]
```
## generator.any([func])

Returns `true` if at least one of the values generated by the source evaluates to true; otherwise
returns `false`. This is a short-circuit operation; as soon as a truthy value is found, evaluation
of the source generator stops.

If the optional function is given, the test is made on the results of calling the function on the
generated values; not on the values themselves. In other words, `gen.any(func)` is equivalent to
`gen.map(func).any()`. Instead of a function, you can also pass a string; see [String selectors](#string-selectors).

The method always returns a boolean, regardless of the actual generated values.

### Example
```javascript
console.log(Generator([0, false, "", null]).any());      // false
console.log(Generator([0, false, "text", null]).any());  // true
```

## generator.count() ===
Returns the number of values generated by the generator. This obviously requires a finite
generator.

### Example

```javascript
var array = [1, 2, 3, 4, 5];
console.log(Generator(array).count()); // 5
delete array[2];
console.log(Generator(array).count()); // 4
```

## generator.evaluated()

This is a shortcut for `new Generator(generator.toArray())`. You should use this e.g. if you need
to iterate a generator multiple times, but the iteration contains expensive functions, or if you
want to make sure that some operation is definitely conducted on all elements, even if you're not
sure it's ever fully iterated.

### Example

```javascript
var numbers = Generator([3, 4, 7, 9, 6]);
var callCount;

function square(x) { callCount++; return x * x; } // let's assume this is a very expensive operation
function isInteresting(x) { return x % 5 ## 1; }
function isBoring(x) { return !isInteresting(x); }

var squares = numbers.map(square);

callCount = 0;
var interestingSquares = squares.filter(isInteresting).toArray();
var boringSquares = squares.filter(isBoring).toArray();
console.log(callCount); // 10

callCount = 0;
squares = squares.evaluated();
var interestingSquares = squares.filter(isInteresting).toArray();
var boringSquares = squares.filter(isBoring).toArray();
console.log(callCount); // 5
```

## generator.except(val)
Returns a new generator that generates all values that the source generator yields, except for
those that are identical to `val` (as defined by the `===` operator).

### Example

```javascript
var numbers = Generator([1, 2, 3, 4, 5, 6, 7, 8, 3, 9]);
console.log(numbers.except(3).toArray()); // [1, 2, 4, 5, 6, 7, 8, 9]
```

## generator.filter(func [, thisObj])

Returns a new generator that generates only those values of the source generator for which the
given function returns a truthy value. If you're used to Linq, you know this method as
`.Where()`. Instead of a function, you can also pass a string; see [String selectors](#string-selectors).

If the additional parameter `thisObj` is given, it will be available to the function as `this`.

### Example
```javascript
var gen = Generator([1, -7, 3, 5, -8, 0, 12, 1, -3]);

var filtered = gen.filter(function (x) { return x > 0; });

console.log(filtered.toArray()); // [1, 3, 5, 12, 1]
```

## generator.first()

Returns the first generated value; evaluation of the source generator stops immediately. If the
generator is empty (generates no values), `.first()` returns `undefined`.

### Example
```javascript
console.log(Generator(["x", "y", "z"]).first()); // x
```

## generator.forEach(func [, thisObj])

Calls the given function on each generated element. The function receives up to three parameters:

* `value` The generated element
* `index` The zero-based index of the element
* `stop` A function that should be called to break out of the iteration

If the additional parameter `thisObj` is given, it will be available to the function as `this`.

The return value of the function (if any) will be given to the generator function as the result of
the `Yield()` call.

Stopping happens by throwing `Generator.BreakIteration`, so if your `Yield()` or `stop()` call
happens in a `try/catch` block, be sure to re-throw this exception.

### Example 1

```javascript
var gen = Generator([1, 2, 42, 5]);
gen.forEach(function (value, index, stop) {
    console.log("Value number " + index + " is " + value);
    if (value ## 42) {
        console.log("breaking");
        stop();
    }
});

/* Output:
Value number 0 is 1
Value number 1 is 2
Value number 2 is 42
breaking
*/
```

### Example 2
```javascript
var gen = Generator(function (Yield) {
    var i = 0;
    while (true) {
        if (Yield(i) ## "stop")
            break;
        i++;
    }
    Yield("that's all");
});

gen.forEach(function (val) {
    console.log(val);
    if (val > 2)
        return "stop";
});

/* Output:
0
1
2
3
that's all
*/
```

## generator.groupBy(grouperFunction)

Returns a generator that in turn yields generators, or groups. All values of the source generator
for which `grouperFunction` returns identical values (as defined by the `===` operator) are put
into one group. Instead of a function, you can also pass a string; see [String selectors](#string-selectors).

A group (generator) has an additional property `key`, which is the result of calling
`grouperFunction` on each of the values in this group.

**Note:** The semantics of this method are similar to those of Linq's `.GroupBy()`, *not* Python's
`itertools.groupby`. This means that there is no need for values in the same group to be already
yielded consecutively. On the flip side, this also means that the source generator will be *fully*
evaluted as soon as the result of `.groupBy()` starts being evaluated. In particular, you cannot
group infinite generators.

The order of the groups as generated is the order in which the first element of the group appears
in the source. Within the group, elements are generated in the order they appear in the source.

### Example

```javascript
var values = Generator(["hello", 13, null, -1.1, alert, "yes", true, { answer: 42 }]);

var groupedByType = values.groupBy(function (v) { return typeof v; });

groupedByType.forEach(function (group) {
    console.log("Values of type " + group.key + ":");
    group.forEach(function (val) {
        console.log("- " + val);
    });
});

/* Output:
Values of type string:
- hello
- yes
Values of type number:
- 13
- -1.1
Values of type object:
- null
- [object Object]
Values of type function:
- function alert() { [native code] }
Values of type boolean:
- true
*/
```

## generator.map(func [, thisObj]) ===
Returns a new generator whose values are the results of applying the given function to each of the
source elements. If you're used to Linq, you know this method as `.Select()`. Instead of a
function, you can also pass a string; see [String selectors](#string-selectors) at the top of this page.

If the additional parameter `thisObj` is given, it will be available to the function as `this`.

### Example

```javascript
var gen = Generator([0, null, false, undefined]);

var types = gen.map(function (x) { return typeof x; });

console.log(types.toArray()); // ["number", "object", "boolean", "undefined"]
```

## generator.reduce(func [, startValue])

Returns the value resulting from repeatedly calling `func` with two arguments: The previous result
of calling `func` (or `startValue```), and the next value in the sequence. If `startValue` is not
given, the first call to func will be made with the first two generated elements.

If you're used to Linq, you know this method as `.Aggregate()`.

### Example

```javascript
var numbers = Generator(function (Yield) {
    for (var i = 1; i <= 6; i++)
        Yield(i);
});

function multiply(a, b) {
    return a * b;
}

console.log("6! = " + numbers.reduce(multiply)); // 6! = 720
```

## generator.skip(n)
Returns a new generator that generates all but the first `n` values of the source generator.

### Example
```javascript
var gen = Generator(function (Yield) {
    Yield("start");
    for (var i = 1; i < 5; i++)
        Yield(i);
    Yield("end");
});

console.log(gen.skip(3).toArray()); // [3, 4, "end"]
```

## generator.skipWhile(func)

Returns a new generator that generates all values of the source generator, except for a consecutive run of values at the beginning for which the given function returns a truthy value. As soon as this function has returned false, it will not be called again. The first value generated is the one for which the function returned false. Instead of a function, you can also pass a string; see [String selectors](#string-selectors) at the top of this page.

### Example

```javascript
var strings = Generator(["Many", "words", "have", "few", "letters"]);
var isLong = function (s) { return s.length > 3 };

console.log(strings.skipWhile(isLong).toArray()); // ["few", "letters"]
```


## generator.sortBy(func)

Returns a new generator that generates the values of the (finite!) source generator, sorted in
ascending order by the value that `func` returns. Instead of a function, you can also pass a
string; see [String selectors](#string-selectors).

This function is not as flexible as JavaScript's `Array.sort`, but is made for the usual case that
you're sorting by some value or string. The two major differences:

* `generator.sortBy` is guaranteed to be stable; if two values compare equal, they will appear in
the same order in the sorted version as they appeared in the source.
* `generator.sortBy` is type strict: If `func` returns different types for different values,
evaluating the generator will throw an exception. The same thing will happen if two return values
of `func` have to be compared, but aren't comparable, i.e. `a < b`, `a > b `, and `a ## b` are all
false.

In other words: `func` should usually return either only numbers or only strings.

### Example

```javascript
var strings = Generator(["All", "is", "well", "that", "yields", "well"]);

// Outputs: ["is", "All", "well", "that", "well", "yields"]
console.log(strings.sortBy(function (s) { return s.length; }).toArray());
```

## generator.take(n)
Returns a new generator that generates only the first `n` values of the source generator.

### Example
```javascript
var gen = Generator(function (Yield) {
    Yield("start");
    for (var i = 1; i < 5; i++)
        Yield(i);
    Yield("end");
});

console.log(gen.take(3).toArray()); // ["start", 1, 2]
```

## generator.takeWhile(func) ===
Returns a new generator that generates values from the beginning of the source generator, and stops
when it finds a value for which the given function returns a falsy value. Evaluation of the source
generator stops at this point, so the predicate function will only return false once.
Instead of a function, you can also pass a string; see [String selectors](#string-selectors).

### Example

```
#!javascript
var strings = Generator(["Many", "words", "have", "few", "letters"]);
var isLong = function (s) { return s.length > 3 };

console.log(strings.takeWhile(isLong).toArray()); // ["Many", "words", "have"]
```

## generator.toArray() ===

Returns an array that contains the generated elements. The generator must obviously be finite;
otherwise this causes an infinite loop.

### Example

```
var gen = Generator(function (Yield) {
    Yield("Hello");
    Yield("and");
    Yield("goodbye");
});

var array = gen.toArray();
console.log(array); // ["Hello", "and", "goodbye"]
```

## generator.zipWithArray(array [, zipperFunc])
Returns a new generator whose values are the result of calling `zipperFunc` with two arguments: An
element from the source generator, and the corresponding element of the array.

Due to the way generators are implemented, it is impossible to make this work with two generators
(in particular, two infinite generators), hence we can only zip with (finite) arrays. So if you
want to zip two generators, one of them has to be turned into an array with `.toArray()`.

The number of resulting generated elements is either the number of elements generated by the source
generator, or the length of the array; whichever one is shorter.

The `zipperFunc` is optional, and defaults to creating two-element arrays `[a, b]`, where `a` comes
from the source generator, and `b` from the zipped-with array.

### Example
```javascript
var x1 = Generator([3, 17, -5, 9]);
var x2 = Generator(function (Yield) {
    Yield(2);
    Yield(8);
    Yield(3);
});

function difference (a, b) {
    return a - b;
}

var pointwiseDifference = x1.zipWithArray(x2.toArray(), difference);

console.log(pointwiseDifference.toArray()); // [1, 9, -8]
```